import asyncio
import json
from dotenv import load_dotenv
import os
import warnings
import logging
from fastapi import WebSocket, WebSocketDisconnect
from google.genai import types
from mcp import ClientSession
from mcp.client.sse import sse_client
from litellm import experimental_mcp_client
from ws_manager import ConnectionManager
from google import genai
from google.genai.types import GenerateContentConfig, HttpOptions
from google.adk.agents import Agent
from google.adk.models.lite_llm import LiteLlm
import litellm
from pydantic import BaseModel

warnings.filterwarnings("ignore")
logging.basicConfig(level=logging.ERROR)
load_dotenv()
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
MCP_SERVER_URL = os.getenv("MCP_SERVER_URL", "http://localhost:8000/mcp-server/sse/")

manager = ConnectionManager()

async def categorize_email(email_body):
    """Categorizes email content using Gemini API."""
    client = genai.Client(api_key=GEMINI_API_KEY)
    async with sse_client(MCP_SERVER_URL) as streams:
        async with ClientSession(*streams) as session:
            await session.initialize()
            mcp_tools = await experimental_mcp_client.load_mcp_tools(session=session, format="mcp")
            if not mcp_tools:
                logging.warning("No MCP tools available.")
                return "unknown"
            response = client.models.generate_content(
                model="gemini-2.0-flash",
                contents=[email_body],
                config=GenerateContentConfig(
                    system_instruction=["You are a Gmail agent. Your task is to use the available tools."],
                    tools=mcp_tools
                ),
            )
            if response.candidates and response.candidates[0].content.parts:
                for part in response.candidates[0].content.parts:
                    if hasattr(part, 'function_call') and part.function_call is not None:
                        function_call = part.function_call
                        try:
                            result = await session.call_tool(
                                function_call.name, arguments=dict(function_call.args)
                            )
                            try:
                                email_data = json.loads(result.content[0].text)
                                return email_data
                            except json.JSONDecodeError as je:
                                logging.error(f"MCP server returned non-JSON response for {function_call.name}: {result.content[0].text} - Error: {je}")
                            except (IndexError, AttributeError) as ae:
                                logging.error(f"Unexpected result structure from MCP tool {function_call.name}: {result} - Error: {ae}")
                        except Exception as mcp_e:
                            logging.error(f"Error calling MCP tool {function_call.name}: {mcp_e}")
                    else:
                        logging.info("No function call generated by Gemini. Model response (if any): %s", response.text if response.text else "No text response.")
            else:
                logging.warning("No candidates or content parts in Gemini response.")
            return "unknown"


# --- WebSocket Agent Chat Logic ---
async def agent_websocket(websocket: WebSocket):
    session_id = None
    try:
        session_id = str(id(websocket)) # Simple session ID based on websocket object ID
        await manager.connect(websocket, session_id)
        await manager.send_personal_message(session_id, {"message": "Agent chat connected.", "session_id": session_id})

        while True:
            try:
                data = await websocket.receive_text()
                logging.info(f"Received message from {session_id}: {data}")

                try:
                    result = await categorize_email(data)
                    await manager.send_personal_message(session_id, {"message": result})
                except (ValueError, ConnectionError, RuntimeError) as e_cat: # Catch specific errors from categorize_email
                    logging.error(f"Categorization error for session {session_id}: {e_cat}", exc_info=True)
                    error_message = str(e_cat)
                    # Make messages more user-friendly for specific cases
                    if isinstance(e_cat, ConnectionError):
                        error_message = "Could not connect to a required service. Please try again later."
                    elif "API Key" in str(e_cat) or "API policy" in str(e_cat):
                         error_message = "There's an issue with the categorization service configuration."

                    await manager.send_personal_message(session_id, {"error": error_message})
                except Exception as e_inner_loop: # Catch any other unexpected errors from categorize_email
                    logging.error(f"Unexpected error during categorization for session {session_id}: {e_inner_loop}", exc_info=True)
                    await manager.send_personal_message(session_id, {"error": "An unexpected error occurred while processing your request."})

            except WebSocketDisconnect:
                logging.info(f"WebSocket disconnected for session {session_id}.")
                break # Exit the loop gracefully on WebSocketDisconnect
            except Exception as e_outer_loop: # Catch errors from websocket.receive_text() or manager.send
                logging.error(f"Error in WebSocket communication for session {session_id}: {e_outer_loop}", exc_info=True)
                # Attempt to send an error message if the connection is still partly alive
                try:
                    await manager.send_personal_message(session_id, {"error": "A communication error occurred."})
                except Exception: # Ignore if sending also fails
                    pass
                break # Exit loop on other errors too to prevent potential infinite loops

    except Exception as e_connect: # Errors during initial connect or if manager.send_personal_message fails initially
        logging.error(f"Error during WebSocket setup or initial message for session {session_id or 'unknown'}: {e_connect}", exc_info=True)
        # No websocket.send_json here as connection might be compromised
    finally:
        if session_id:
            logging.info(f"Disconnecting session {session_id}.")
            manager.disconnect(session_id)

# Optional: Standalone test
if __name__ == '__main__':
    asyncio.run(categorize_email("write email to yousif@test.com. tell him it works now."))
