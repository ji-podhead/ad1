import asyncio
import json
from dotenv import load_dotenv
import os
import warnings
import logging
from fastapi import WebSocket, WebSocketDisconnect
from google import genai
from google.genai.types import GenerateContentConfig, HttpOptions
from mcp import ClientSession
from mcp.client.sse import sse_client
from litellm import experimental_mcp_client
from ws_manager import ConnectionManager

warnings.filterwarnings("ignore")
logging.basicConfig(level=logging.ERROR)
load_dotenv()
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
MCP_SERVER_URL = os.getenv("MCP_SERVER_URL", "http://localhost:8000/mcp-server/sse/")

manager = ConnectionManager()

async def categorize_email(email_body):
    """Categorizes email content using Gemini API."""
    try:
        client = genai.Client(api_key=GEMINI_API_KEY)
        if not GEMINI_API_KEY:
            logging.error("GEMINI_API_KEY is not set.")
            raise ValueError("Missing Gemini API Key")

        async with sse_client(MCP_SERVER_URL) as streams:
            async with ClientSession(*streams) as session:
                await session.initialize()
                mcp_tools = await experimental_mcp_client.load_mcp_tools(session=session, format="mcp")

                if not mcp_tools:
                    logging.warning("No MCP tools available.")
                    # Depending on strictness, could return "unknown" or raise error
                    # For now, let it proceed, Gemini might respond without tools or error out.
                    # return "unknown" # Or raise specific error

                logging.info(f"Using {len(mcp_tools)} MCP tools for categorization.")

                response = client.models.generate_content(
                    model="gemini-2.0-flash", # Consider making model configurable
                    contents=[email_body],
                    config=GenerateContentConfig(
                        system_instruction=["You are a Gmail agent. Your task is to use the available tools."],
                        tools=mcp_tools
                    ),
                )
                logging.debug(f"Gemini API response: {response}")

                if response.candidates and response.candidates[0].content.parts:
                    for part in response.candidates[0].content.parts:
                        if hasattr(part, 'function_call') and part.function_call is not None:
                            function_call = part.function_call
                            logging.info(f"Gemini requested function call: {function_call.name} with args: {dict(function_call.args)}")
                            try:
                                result = await session.call_tool(
                                    function_call.name, arguments=dict(function_call.args)
                                )
                                logging.debug(f"MCP tool result: {result.content}")
                                try:
                                    # Assuming result.content[0].text is the JSON string
                                    email_data = json.loads(result.content[0].text)
                                    return email_data
                                except json.JSONDecodeError as je:
                                    logging.error(f"MCP server returned non-JSON response for {function_call.name}: {result.content[0].text} - Error: {je}")
                                    raise ValueError(f"Invalid response format from tool {function_call.name}.")
                                except (IndexError, AttributeError) as ae:
                                    logging.error(f"Unexpected result structure from MCP tool {function_call.name}: {result} - Error: {ae}")
                                    raise ValueError(f"Unexpected data structure from tool {function_call.name}.")
                            except Exception as mcp_e: # Catch errors during MCP call_tool
                                logging.error(f"Error calling MCP tool {function_call.name}: {mcp_e}")
                                raise ConnectionError(f"Failed to execute tool {function_call.name} via MCP.")
                        else:
                            # This case means Gemini responded but didn't use a function call
                            logging.info("No function call generated by Gemini. Model response (if any): %s", response.text if response.text else "No text response.")
                else:
                    logging.warning("No candidates or content parts in Gemini response.")

        # Fallback if no function call path returned or other issues within sse/ClientSession
        logging.warning("Categorization did not result in a function call or successful data extraction.")
        return "unknown" # Default fallback

    except genai.types.generation_types.BlockedPromptException as bpe:
        logging.error(f"Gemini API blocked the prompt: {bpe}")
        raise ValueError("Content blocked by API policy.")
    except (genai.types.HttpError, genai.types.BrokenResponseError) as ge: # More specific Gemini client errors
        logging.error(f"Gemini API communication error: {ge}")
        raise ConnectionError(f"Failed to communicate with Gemini API: {ge}")
    except ConnectionError as ce: # Catch ConnectionError from MCP or re-raised Gemini ConnectionError
        # This allows specific handling of connection issues in agent_websocket
        raise ce
    except ValueError as ve: # Catch ValueError from API key, JSON parsing, blocked content
        raise ve
    except Exception as e:
        logging.error(f"Unexpected error in categorize_email: {e}", exc_info=True)
        # Raise a generic error that can be caught by the WebSocket handler
        raise RuntimeError(f"An unexpected issue occurred during email processing: {e}")


# --- WebSocket Agent Chat Logic ---
async def agent_websocket(websocket: WebSocket):
    session_id = None
    try:
        session_id = str(id(websocket)) # Simple session ID based on websocket object ID
        await manager.connect(websocket, session_id)
        await manager.send_personal_message(session_id, {"message": "Agent chat connected.", "session_id": session_id})

        while True:
            try:
                data = await websocket.receive_text()
                logging.info(f"Received message from {session_id}: {data}")

                try:
                    result = await categorize_email(data)
                    await manager.send_personal_message(session_id, {"message": result})
                except (ValueError, ConnectionError, RuntimeError) as e_cat: # Catch specific errors from categorize_email
                    logging.error(f"Categorization error for session {session_id}: {e_cat}", exc_info=True)
                    error_message = str(e_cat)
                    # Make messages more user-friendly for specific cases
                    if isinstance(e_cat, ConnectionError):
                        error_message = "Could not connect to a required service. Please try again later."
                    elif "API Key" in str(e_cat) or "API policy" in str(e_cat):
                         error_message = "There's an issue with the categorization service configuration."

                    await manager.send_personal_message(session_id, {"error": error_message})
                except Exception as e_inner_loop: # Catch any other unexpected errors from categorize_email
                    logging.error(f"Unexpected error during categorization for session {session_id}: {e_inner_loop}", exc_info=True)
                    await manager.send_personal_message(session_id, {"error": "An unexpected error occurred while processing your request."})

            except WebSocketDisconnect:
                logging.info(f"WebSocket disconnected for session {session_id}.")
                break # Exit the loop gracefully on WebSocketDisconnect
            except Exception as e_outer_loop: # Catch errors from websocket.receive_text() or manager.send
                logging.error(f"Error in WebSocket communication for session {session_id}: {e_outer_loop}", exc_info=True)
                # Attempt to send an error message if the connection is still partly alive
                try:
                    await manager.send_personal_message(session_id, {"error": "A communication error occurred."})
                except Exception: # Ignore if sending also fails
                    pass
                break # Exit loop on other errors too to prevent potential infinite loops

    except Exception as e_connect: # Errors during initial connect or if manager.send_personal_message fails initially
        logging.error(f"Error during WebSocket setup or initial message for session {session_id or 'unknown'}: {e_connect}", exc_info=True)
        # No websocket.send_json here as connection might be compromised
    finally:
        if session_id:
            logging.info(f"Disconnecting session {session_id}.")
            manager.disconnect(session_id)

# Optional: Standalone test
if __name__ == '__main__':
    asyncio.run(categorize_email("write email to yousif@test.com. tell him it works now."))
